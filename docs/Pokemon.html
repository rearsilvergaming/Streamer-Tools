<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pokémon Spawner Overlay</title>
    <style>
      /* Full-screen transparent overlay */
      body {
        background-color: transparent;
        margin: 0;
        padding: 0;
        overflow: hidden;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        width: 100vw;
        font-family: "Inter", sans-serif;
      }

      /* === LAYOUT GRID === */

      /* Wrapper: centred on screen */
      #pokemon-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        opacity: 0; /* faded in by JS */
        transition: opacity 0.25s ease-out;
      }

      /* Fixed battle cell – all action happens inside this box */
      .battle-cell {
        position: relative;
        width: 350px;
        height: 350px;
        pointer-events: none;
      }

      /* Layer stacks inside the cell */
      .fx-layer,
      .pokemon-layer {
        position: absolute;
        inset: 0;
        pointer-events: none;
      }

      /* Wrapper that is centred in the cell –
         the Pokémon image moves inside this */
      #pokemon-wrapper {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
      }

      /* --- SPRITES --- */

      /* Pokémon sprite (variable PNG size – we rescale in JS) */
      #pokemon-image {
        position: relative;
        display: block;
        margin: 0 auto;
        user-select: none;
        filter: drop-shadow(0 0 15px rgba(255, 255, 255, 0.6));
        transform-origin: center center;
        opacity: 0;
      }

      /* Pokéball sits in front of centre, slightly below */
      #pokeball-image {
        position: absolute;
        top: 55%;
        left: 55%;
        width: 80px;
        height: 80px;
        object-fit: contain;
        user-select: none;
        transform: translate(-50%, -50%);
        opacity: 0;
        display: none;
        z-index: 10;
        transition: opacity 0.2s ease-out, transform 0.2s ease-out;
      }

      /* FX: speed lines (behind Pokémon) */
      #speed-lines {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 260px;
        height: auto;
        opacity: 0;
        user-select: none;
        pointer-events: none;
        z-index: 2;
      }

      /* FX: dust, to the LEFT of Pokémon but same row
         We offset leftwards from the Pokémon centre */
      #dust-small,
      #dust-large {
        position: absolute;
        top: 50%;
        left: 50%;
        /* this puts the dust to the left of the mon */
        transform: translate(-140%, -50%);
        width: auto;
        height: auto;
        opacity: 0;
        user-select: none;
        pointer-events: none;
        z-index: 3;
      }

      #dust-small {
        max-width: 180px;
      }

      #dust-large {
        max-width: 260px;
      }

      /* Name / info text – fixed under the battle cell */
      #pokemon-info {
        margin-top: 10px;
        color: white;
        background-color: rgba(0, 0, 0, 0.7);
        padding: 8px 15px;
        border-radius: 10px;
        font-size: 1.5rem;
        font-weight: bold;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        border: 2px solid #ffcb05;
        opacity: 0;
        transition: opacity 0.35s ease-out;
        z-index: 20;
      }

      /* === ANIMATIONS === */

      /* 1. Pokémon run-in from right, classic slide + bounce */
      .animate-run-in {
        animation: runIn 2s cubic-bezier(0.17, 0.89, 0.32, 1.49) forwards;
      }

      @keyframes runIn {
        0% {
          opacity: 0;
          transform: translateX(160px) scale(1);
        }
        30% {
          opacity: 1;
          transform: translateX(40px) scale(1.05);
        }
        70% {
          opacity: 1;
          transform: translateX(-10px) scale(0.97);
        }
        100% {
          opacity: 1;
          transform: translateX(0px) scale(1);
        }
      }

      /* 2. Speed lines flash behind the Pokémon */
      .animate-speed-lines {
        animation: speedLinesFlash 2s ease-out forwards;
      }

      @keyframes speedLinesFlash {
        0% {
          opacity: 0;
          transform: translate(50%, -50%) translateX(40px);
        }
        20% {
          opacity: 1;
          transform: translate(50%, -50%) translateX(0px);
        }
        100% {
          opacity: 0;
          transform: translate(50%, -50%) translateX(-40px);
        }
      }

      /* 3. Dust bursts (small then large) */
      .animate-dust-small {
        animation: dustSmallBurst 2s ease-out forwards;
      }

      @keyframes dustSmallBurst {
        0% {
          opacity: 0;
          transform: translate(140%, -50%) scale(0.5);
        }
        35% {
          opacity: 1;
          transform: translate(135%, -52%) scale(1.05);
        }
        100% {
          opacity: 0;
          transform: translate(130%, -48%) scale(1.2);
        }
      }

      .animate-dust-large {
        animation: dustLargeBurst 2s ease-out forwards;
      }

      @keyframes dustLargeBurst {
        0% {
          opacity: 0;
          transform: translate(180%, -50%) scale(0.6);
        }
        40% {
          opacity: 1;
          transform: translate(138%, -51%) scale(1.05);
        }
        100% {
          opacity: 0;
          transform: translate(132%, -49%) scale(1.25);
        }
      }

      /* Existing catch logic animations, adapted for new layout */

      .animate-pokeball-throw {
        animation: pokeballArcAndHit 0.8s cubic-bezier(0.68, -0.55, 0.265, 1.55)
          forwards;
      }

      /* New Pokéball throw with hit impact */
      @keyframes pokeballArcAndHit {
        0% {
          opacity: 0;
          transform: translate(-200px, 200px) rotate(0deg) scale(0);
        }
        50% {
          opacity: 1;
          transform: translate(-40px, -120px) rotate(360deg) scale(1.2);
        }
        70% {
          /* Ball arrives at centre and bumps */
          transform: translate(0px, -10px) rotate(540deg) scale(1);
        }
        85% {
          /* Little bounce upward */
          transform: translate(0px, -20px) rotate(560deg) scale(1);
        }
        100% {
          /* Settles in front of Pokémon */
          opacity: 1;
          transform: translate(0px, 0px) rotate(720deg) scale(1);
        }
      }

      /* Pokémon sucked into ball */
      .animate-suck-in {
        animation: suckIn 0.5s ease-in forwards;
      }

      @keyframes suckIn {
        0% {
          opacity: 1;
          transform: scale(1) translateY(0);
          filter: drop-shadow(0 0 15px rgba(255, 255, 255, 0.6));
        }
        100% {
          opacity: 0.2;
          transform: scale(0) translate(20px, 20px);
          filter: brightness(5) hue-rotate(90deg);
        }
      }

      /* Pokéball wiggle */
      .animate-wiggle {
        animation: wiggle 0.2s ease-in-out infinite alternate;
      }

      @keyframes wiggle {
        0% {
          transform: translate(0px, 0px) rotate(0deg);
        }
        50% {
          transform: translate(5px, 5px) rotate(5deg);
        }
        100% {
          transform: translate(-5px, 5px) rotate(-5deg);
        }
      }

      /* Pokémon escapes from ball */
      .animate-catch-fail-escape {
        animation: catchFailEscape 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94)
          forwards;
      }

      @keyframes catchFailEscape {
        0% {
          opacity: 0.5;
          transform: scale(0) translate(20px, 20px);
        }
        50% {
          opacity: 1;
          transform: scale(1.1) translateY(-20px);
          filter: brightness(1) drop-shadow(0 0 15px rgba(255, 255, 255, 0.6));
        }
        100% {
          opacity: 1;
          transform: scale(1) translateY(0);
        }
      }

      /* Catch success – ball glow then shrink */
      .animate-catch-success {
        animation: catchSuccess 1.5s ease-out forwards;
      }

      @keyframes catchSuccess {
        0% {
          opacity: 1;
          transform: scale(1);
          filter: drop-shadow(0 0 10px rgba(255, 0, 0, 0.8));
        }
        50% {
          opacity: 1;
          transform: scale(1.2);
          filter: drop-shadow(0 0 30px rgba(0, 255, 0, 1));
        }
        100% {
          opacity: 0;
          transform: scale(0.1);
        }
      }

      /* Flee to the right */
      .animate-flee-run {
        animation: fleeRun 1s ease-in forwards;
      }

      @keyframes fleeRun {
        0% {
          opacity: 1;
          transform: translateX(0) scale(1);
        }
        100% {
          opacity: 1;
          transform: translateX(500px) scale(1);
        }
      }

      .animate-fade-out {
        opacity: 0 !important;
        transition: opacity 1s ease-out;
      }

      /* === SHINY FX === */

      .shiny-glow {
        filter: drop-shadow(0 0 15px rgba(255, 215, 0, 1))
          drop-shadow(0 0 40px rgba(255, 215, 0, 0.8)) brightness(1.3);
      }

      .shiny-hue-pulse {
        animation: shinyHue 2.2s ease-in-out infinite alternate;
      }

      @keyframes shinyHue {
        0% {
          filter: hue-rotate(0deg) brightness(1.25);
        }
        100% {
          filter: hue-rotate(45deg) brightness(1.5);
        }
      }

      /* Sparkle overlay */
      .shiny-sparkles {
        position: absolute;
        inset: 0;
        pointer-events: none;
        background-image: url("https://raw.githubusercontent.com/rearsilvergaming/Streamer-Tools/main/docs/Pokemon/ShinySparkles.png");
        background-size: contain;
        background-repeat: no-repeat;
        background-position: center;
        opacity: 0;
        animation: shinySparkleFade 2s ease-out forwards;
      }

      @keyframes shinySparkleFade {
        0% {
          opacity: 0;
          transform: scale(0.5);
        }
        20% {
          opacity: 1;
          transform: scale(1.1);
        }
        100% {
          opacity: 0;
          transform: scale(1.3);
        }
      }

      /* === SHINY CATCH SUCCESS ANIMATION === */

      .animate-shiny-success {
        animation: shinyCatchFinal 1.7s ease-out forwards;
      }

      @keyframes shinyCatchFinal {
        0% {
          opacity: 1;
          transform: scale(1);
          filter: drop-shadow(0 0 20px gold)
            drop-shadow(0 0 40px rgba(255, 215, 0, 1));
        }
        40% {
          opacity: 1;
          transform: scale(1.3);
          filter: drop-shadow(0 0 55px gold)
            drop-shadow(0 0 85px rgba(255, 215, 0, 1));
        }
        100% {
          opacity: 0;
          transform: scale(0.1);
          filter: drop-shadow(0 0 15px gold);
        }
      }

      /* === SCREEN SHAKE === */
      .screen-shake {
        animation: screenShake 0.35s cubic-bezier(0.36, 0.07, 0.19, 0.97);
      }

      @keyframes screenShake {
        0% {
          transform: translate(0, 0);
        }
        20% {
          transform: translate(-6px, 4px);
        }
        40% {
          transform: translate(5px, -5px);
        }
        60% {
          transform: translate(-4px, 3px);
        }
        80% {
          transform: translate(3px, -4px);
        }
        100% {
          transform: translate(0, 0);
        }
      }

      /* === IDLE BOUNCE === */
      .idle-bounce {
        animation: idleBounce 2.6s ease-in-out infinite;
      }

      @keyframes idleBounce {
        0%,
        100% {
          transform: translateY(0);
        }
        50% {
          transform: translateY(-4px);
        }
      }

      /* === MISSED THROW (Pokéball flies past and falls off-screen) === */
      .animate-miss-throw {
        animation: missThrow 0.9s ease-out forwards;
      }

      @keyframes missThrow {
        0% {
          opacity: 0;
          transform: translate(-200px, 150px) rotate(0deg) scale(0.1);
        }
        40% {
          opacity: 1;
          transform: translate(40px, -120px) rotate(360deg) scale(1.2);
        }
        70% {
          transform: translate(200px, 20px) rotate(500deg) scale(1);
        }
        100% {
          opacity: 0;
          transform: translate(350px, 220px) rotate(720deg) scale(0.3);
        }
      }
    </style>
  </head>
  <body>
    <div id="pokemon-container">
      <div class="battle-cell">
        <!-- FX layer -->
        <div class="fx-layer">
          <img
            id="speed-lines"
            src=""
            alt="Speed Lines"
            onerror="console.error('Speed lines failed to load from:', this.src)"
          />
          <img
            id="dust-small"
            src=""
            alt="Small Dust Cloud"
            onerror="console.error('Small dust cloud failed to load from:', this.src)"
          />
          <img
            id="dust-large"
            src=""
            alt="Large Dust Cloud"
            onerror="console.error('Large dust cloud failed to load from:', this.src)"
          />
        </div>

        <!-- Pokémon + Pokéball layer -->
        <div class="pokemon-layer">
          <div id="pokemon-wrapper">
            <img
              id="pokemon-image"
              src=""
              alt="Wild Pokemon"
              onerror="console.error('Pokemon image failed to load from:', this.src)"
            />
          </div>
          <div id="shiny-sparkle-layer" class="fx-layer"></div>
          <img
            id="pokeball-image"
            src=""
            alt="Pokeball"
            onerror="console.error('Pokeball image failed to load from:', this.src)"
          />
        </div>
      </div>

      <!-- Name / info text -->
      <div id="pokemon-info"></div>
    </div>

    <script>
      /* ============================================================
=== Streamer.bot WebSocket Connection (Reliable Version) ===
============================================================ */

      let ws;
      let lastMessageTime = Date.now();
      let reconnectAttempts = 0;

      // How long the overlay can be silent before warning SB (ms)
      const MAX_SILENCE_MS = 40000;

      // Try all valid Streamer.bot endpoints
      const endpoints = [
        "ws://127.0.0.1:8080",
        "ws://localhost:8080",
        "ws://127.0.0.1:8081",
      ];

      // ---- Optional: tiny heartbeat ping ----
      function sendHeartbeat() {
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(
            JSON.stringify({ request: "Ping", id: "pokemon-overlay-heartbeat" })
          );
        }
      }
      // ---- WebSocket connection with reconnect logic ----

      function startWebSocket(endpointIndex = 0) {
        const url = endpoints[endpointIndex % endpoints.length];
        console.log("[WebSocket] Connecting to:", url);

        try {
          ws = new WebSocket(url);
        } catch (err) {
          console.error("WS Connection failed immediately:", err);
          scheduleReconnect(endpointIndex + 1);
          return;
        }

        ws.onopen = () => {
          console.log("%c[WebSocket] Connected → " + url, "color: #4CAF50");

          reconnectAttempts = 0;
          lastMessageTime = Date.now();

          const subscribeMessage = {
            request: "Subscribe",
            id: "pokemon-overlay",
            events: {
              general: ["Custom"], // WebsocketBroadcastJson() comes through here
              raw: ["Action"], // Backup
            },
          };

          ws.send(JSON.stringify(subscribeMessage));
          console.log("[WebSocket] Subscribed to Custom events");
        };

        ws.onmessage = (event) => {
          lastMessageTime = Date.now();

          let msg;
          try {
            msg = JSON.parse(event.data);
          } catch (e) {
            console.error("WS JSON parse error:", e);
            return;
          }

          console.log("WebSocket message:", msg);

          /* =============================
       Payload format from:
       CPH.WebsocketBroadcastJson()
       -----------------------------
       {
         event:{ source:"General", type:"Custom" },
         data:{
           command:"spawn",
           pokemonName:"Pikachu",
           ...
         }
       }
       ============================= */

          if (msg.data && msg.data.command) {
            const payload = msg.data;
            routePokemonCommand(payload);
            return;
          }

          // Fallback: some older SB versions use msg.type+msg.data.data
          if (msg.type && msg.data && msg.data.data && msg.data.data.command) {
            routePokemonCommand(msg.data.data);
            return;
          }
        };

        ws.onerror = () => {
          console.warn("[WebSocket] Error — closing socket");
          try {
            ws.close();
          } catch {}
        };

        ws.onclose = () => {
          console.warn("[WebSocket] Closed — attempting reconnect…");
          scheduleReconnect(endpointIndex + 1);
        };
      }

      function scheduleReconnect(nextIndex) {
        reconnectAttempts++;
        const delay = Math.min(1000 * reconnectAttempts, 8000); // cap at 8s
        setTimeout(() => startWebSocket(nextIndex), delay);
      }

      // ---- Route incoming commands to overlay logic ----
      function routePokemonCommand(payload) {
        switch (payload.command) {
          case "spawn":
            handleSpawn(payload);
            break;
          case "throw":
            handleThrow(payload);
            break;
          case "wiggle":
            handleWiggle(payload);
            break;
          case "catchSuccess":
            handleCatchSuccess(payload);
            break;
          case "catchFail":
            handleCatchFail(payload);
            break;
          case "flee":
            handleDisappear(payload);
            break;
          case "miss":
            handleMissThrow(payload);
            break;
          case "_keepalive":
            // No-op: keeps OBS browser source alive
            return;
        }
      }

      // ---- Heartbeat + silence watchdog ----
      setInterval(() => {
        // Ping SB so the connection stays warm
        sendHeartbeat();

        const silentFor = Date.now() - lastMessageTime;
        if (silentFor > MAX_SILENCE_MS) {
          console.warn(
            "[Overlay] No activity detected — forcing browser reload"
          );
          location.reload();
        }
      }, 5000);

      // Kick everything off
      startWebSocket();

      /* =====================================================
   === Pokémon Overlay Logic ===
   ===================================================== */

      const container = document.getElementById("pokemon-container");
      const pokemonImage = document.getElementById("pokemon-image");
      const pokemonInfo = document.getElementById("pokemon-info");
      const pokeballImage = document.getElementById("pokeball-image");
      const speedLines = document.getElementById("speed-lines");
      const dustSmall = document.getElementById("dust-small");
      const dustLarge = document.getElementById("dust-large");

      const BASE_IMAGE_URL =
        "https://raw.githubusercontent.com/rearsilvergaming/Streamer-Tools/main/docs/Pokemon/";

      const POKEBALL_URL = BASE_IMAGE_URL + "PokeBall%20-%20Realistic.png";
      const SPEED_LINES_URL = BASE_IMAGE_URL + "Speed%20Lines.png";
      const DUST_SMALL_URL = BASE_IMAGE_URL + "Small%20Dust%20Cloud.png";
      const DUST_LARGE_URL = BASE_IMAGE_URL + "Large%20Dust%20Cloud.png";

      const THROW_DURATION = 800;
      const ESCAPE_DURATION = 600;
      const SUCCESS_DURATION = 5000;
      const FLEE_DURATION = 1000;

      const BATTLE_CELL_SIZE = 350;
      const POKEMON_MAX_SIZE = BATTLE_CELL_SIZE * 0.75;

      let currentPokemonName = "";

      function resetState() {
        container.style.opacity = "0";
        container.classList.remove("screen-shake");

        [pokemonImage, pokeballImage, speedLines, dustSmall, dustLarge].forEach(
          (el) => {
            if (!el) return;
            el.className = el.className.replace(/\banimate-[a-z-]+\b/g, "");
          }
        );

        pokemonImage.style.opacity = "0";
        pokemonImage.style.transform = "translateX(0) scale(1)";
        pokemonImage.style.width = "";
        pokemonImage.style.height = "";
        pokemonImage.classList.remove(
          "idle-bounce",
          "shiny-glow",
          "shiny-hue-pulse"
        );

        pokeballImage.style.opacity = "0";
        pokeballImage.style.display = "none";
        pokeballImage.classList.remove(
          "animate-miss-throw",
          "animate-pokeball-throw",
          "animate-wiggle",
          "animate-catch-success",
          "animate-shiny-success"
        );

        [speedLines, dustSmall, dustLarge].forEach((el) => {
          if (!el) return;
          el.style.opacity = "0";
        });

        pokemonInfo.style.opacity = "0";
        pokemonInfo.textContent = "";
        pokemonInfo.style.border = "2px solid #ffcb05";

        const shinyLayer = document.getElementById("shiny-sparkle-layer");
        shinyLayer.innerHTML = "";

        currentPokemonName = "";
      }

      function rescalePokemonSprite() {
        const w = pokemonImage.naturalWidth;
        const h = pokemonImage.naturalHeight;
        if (!w || !h) return;

        const scale = w >= h ? POKEMON_MAX_SIZE / w : POKEMON_MAX_SIZE / h;

        pokemonImage.style.width = w * scale + "px";
        pokemonImage.style.height = h * scale + "px";
      }

      function setPokemonSprite(name) {
        const cacheBust = `?v=${Date.now()}`;

        const png = `${BASE_IMAGE_URL}${name}.png${cacheBust}`;
        const webp = `${BASE_IMAGE_URL}${name}.webp${cacheBust}`;
        const fallback = `${BASE_IMAGE_URL}Missing%20Image.png${cacheBust}`;

        // Clear src first to force OBS to drop the old texture
        pokemonImage.src = "";

        pokemonImage.onerror = () => {
          pokemonImage.onerror = () => {
            pokemonImage.src = fallback;
          };
          pokemonImage.src = webp;
        };

        pokemonImage.src = png;
      }

      function handleSpawn(data) {
        resetState();

        currentPokemonName = data.pokemonName;
        const isShiny = data.isShiny === true;

        const cacheBust = `?v=${Date.now()}`;

        // Reset shiny sparkle layer
        const shinyLayer = document.getElementById("shiny-sparkle-layer");
        shinyLayer.innerHTML = "";

        pokemonImage.onload = () => {
          rescalePokemonSprite();
          container.style.opacity = "1";

          requestAnimationFrame(() => {
            // Apply shiny FX if shiny
            if (isShiny) {
              pokemonImage.classList.add("shiny-glow", "shiny-hue-pulse");

              const sparkle = document.createElement("div");
              sparkle.className = "shiny-sparkles";
              shinyLayer.appendChild(sparkle);

              pokemonInfo.style.border = "2px solid gold";
            }

            // Run-in + screen shake + FX
            pokemonImage.classList.add("animate-run-in");
            container.classList.remove("screen-shake");
            requestAnimationFrame(() =>
              container.classList.add("screen-shake")
            );

            pokemonImage.style.opacity = "1";
            speedLines.classList.add("animate-speed-lines");

            setTimeout(
              () => dustSmall.classList.add("animate-dust-small"),
              380
            );
            setTimeout(
              () => dustLarge.classList.add("animate-dust-large"),
              430
            );
          });

          setTimeout(() => {
            pokemonInfo.style.opacity = "1";
          }, 750);

          // Start idle bounce after the main entrance finishes
          setTimeout(() => {
            pokemonImage.classList.add("idle-bounce");
          }, 2200);
        };

        setPokemonSprite(currentPokemonName);
        pokemonInfo.textContent = data.infoText || "";

        speedLines.src = SPEED_LINES_URL + cacheBust;
        dustSmall.src = DUST_SMALL_URL + cacheBust;
        dustLarge.src = DUST_LARGE_URL + cacheBust;
      }

      function handleThrow() {
        if (!currentPokemonName) return;

        const cacheBust = `?v=${Date.now()}`;
        pokeballImage.src = POKEBALL_URL + cacheBust;
        pokeballImage.style.display = "block";
        pokeballImage.style.opacity = "1";

        // Reset any previous throw/miss animations
        pokeballImage.classList.remove(
          "animate-miss-throw",
          "animate-pokeball-throw",
          "animate-catch-success",
          "animate-shiny-success",
          "animate-wiggle"
        );

        // ⭐ SHINY BONUS: make Pokéball glow gold when thrown
        if (pokemonImage.classList.contains("shiny-glow")) {
          pokeballImage.style.filter =
            "drop-shadow(0 0 15px gold) drop-shadow(0 0 35px rgba(255,215,0,0.9)) brightness(1.3)";
        } else {
          // Reset filter for normal mons
          pokeballImage.style.filter = "none";
        }

        // Force reflow before animation
        void pokeballImage.offsetWidth;

        pokeballImage.classList.add("animate-pokeball-throw");

        setTimeout(() => pokemonImage.classList.add("animate-suck-in"), 700);
        setTimeout(() => (pokemonImage.style.opacity = "0"), 1200);
      }

      function handleWiggle() {
        if (pokeballImage.style.display !== "block") return;

        pokeballImage.classList.remove("animate-wiggle");
        requestAnimationFrame(() =>
          pokeballImage.classList.add("animate-wiggle")
        );
      }

      function handleMissThrow() {
        // Play a quick "miss" throw that flies past the Pokémon and falls away
        const cacheBust = `?v=${Date.now()}`;
        pokeballImage.src = POKEBALL_URL + cacheBust;
        pokeballImage.style.display = "block";
        pokeballImage.style.opacity = "1";

        // Clear other animations
        pokeballImage.classList.remove(
          "animate-pokeball-throw",
          "animate-wiggle",
          "animate-catch-success",
          "animate-shiny-success",
          "animate-miss-throw"
        );
        container.classList.remove("screen-shake");

        // Force reflow so we can retrigger animation
        void pokeballImage.offsetWidth;

        pokeballImage.classList.add("animate-miss-throw");
        container.classList.add("screen-shake");

        setTimeout(() => {
          pokeballImage.style.display = "none";
          pokeballImage.classList.remove("animate-miss-throw");
          container.classList.remove("screen-shake");
        }, 1000);
      }

      function handleCatchFail() {
        if (!currentPokemonName) return;

        // Remove ALL animation classes immediately
        pokemonImage.classList.remove(
          "animate-run-in",
          "animate-suck-in",
          "animate-catch-fail-escape",
          "animate-flee-run"
        );

        // Hide Pokéball
        pokeballImage.style.display = "none";
        pokeballImage.classList.remove("animate-wiggle");

        // Hard reset the Pokémon position & scale
        pokemonImage.style.opacity = "1";
        pokemonImage.style.transform = "translate(0,0) scale(1)";

        // Force reflow so the reset is applied BEFORE animation restarts
        void pokemonImage.offsetWidth;

        // Apply the escape animation cleanly
        pokemonImage.classList.add("animate-catch-fail-escape");
        pokemonInfo.textContent = `${currentPokemonName} escaped!`;

        // After animation, restore idle form again
        setTimeout(() => {
          pokemonImage.classList.remove("animate-catch-fail-escape");
          pokemonImage.style.opacity = "1";
          pokemonImage.style.transform = "translate(0,0) scale(1)";
        }, ESCAPE_DURATION + 100);
      }

      function handleCatchSuccess() {
        if (!currentPokemonName || pokeballImage.style.display !== "block")
          return;

        const isShinyCatch = pokemonImage.classList.contains("shiny-glow");

        // Stop wiggle
        pokeballImage.classList.remove("animate-wiggle");
        pokeballImage.classList.remove("animate-catch-success");
        pokeballImage.classList.remove("animate-shiny-success");
        pokeballImage.classList.remove("animate-miss-throw");

        // ⭐ SHINY SUCCESS GLOW
        if (isShinyCatch) {
          pokeballImage.style.filter =
            "drop-shadow(0 0 25px gold) drop-shadow(0 0 45px rgba(255,215,0,1)) brightness(1.4)";
          pokeballImage.classList.add("animate-shiny-success");
        } else {
          pokeballImage.style.filter = "none";
          pokeballImage.classList.add("animate-catch-success");
        }

        // ⭐ SHINY message
        if (isShinyCatch) {
          pokemonInfo.textContent = `${currentPokemonName} was caught! ✨ SHINY!`;
        } else {
          pokemonInfo.textContent = `${currentPokemonName} was caught!`;
        }

        setTimeout(() => {
          pokeballImage.style.display = "none";
          pokeballImage.classList.remove("animate-catch-success");
          pokeballImage.classList.remove("animate-shiny-success");

          container.classList.add("animate-fade-out");
          setTimeout(resetState, 1000);
        }, SUCCESS_DURATION);
      }

      function handleDisappear() {
        if (!currentPokemonName) return;

        pokeballImage.style.display = "none";
        pokemonInfo.textContent = `${currentPokemonName} fled!`;

        triggerFleeFX();

        pokemonImage.style.opacity = "1";
        pokemonImage.classList.add("animate-flee-run");

        setTimeout(resetState, FLEE_DURATION);
      }

      function triggerFleeFX() {
        speedLines.classList.remove("animate-speed-lines");
        dustSmall.classList.remove("animate-dust-small");
        dustLarge.classList.remove("animate-dust-large");

        requestAnimationFrame(() => {
          speedLines.classList.add("animate-speed-lines");
          setTimeout(() => dustSmall.classList.add("animate-dust-small"), 120);
          setTimeout(() => dustLarge.classList.add("animate-dust-large"), 200);
        });
      }
    </script>
  </body>
</html>
