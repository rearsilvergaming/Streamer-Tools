<!DOCTYPE html>
<html lang="en">
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Timeout Eject Animation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      /* Integrated VT323 font from Ban Code */
      @import url("https://fonts.googleapis.com/css2?family=VT323&display=swap");

      /* Styles common to all animated lines, adapted from eject-line */
      .eject-line {
        /* CORRECTED: Using only VT323 font */
        font-family: "VT323", monospace;
        font-size: 5rem; /* Large text, matching Ban code's size */
        color: #fff;
        /* Temporarily removed for initial width calculation in JS, but needed for animation */
        /* white-space: nowrap; */ 
        /* overflow: hidden; */ 
        width: 0; /* Starts with zero width for animation */
        letter-spacing: 0.15em;
        /* Using text-shadow for a punchy look suitable for overlay graphics */
        text-shadow: 0 0 10px rgba(255, 255, 255, 0.7), 4px 4px 0 #000;
        margin: 0; /* Remove default margins */
        padding: 0; /* Remove default padding */
        line-height: 1.2; /* Tighter line spacing */
      }
      
      /* The final state class to correctly display the line after animation */
      .eject-line-final {
          white-space: nowrap;
          overflow: hidden; /* Keep the overflow hidden during the final hold */
          width: fit-content;
      }

      /* The cursor style (only applied dynamically to the active line) */
      .cursor {
        border-right: 0.15em solid white;
      }

      /* Keyframes for the blinking cursor */
      @keyframes blink-caret {
        from,
        to {
          border-color: transparent;
        }
        50% {
          border-color: white;
        }
      }

      /* Keyframes for the typing width are now generated per line in JS */

      /* Colouring styles from the original Timeout code */
      .username {
        color: #ff5050;
      }
      .mod {
        color: #50b3ff;
      }
      .duration {
        color: #ffff50;
      }
      .reason {
        color: #a0ff90;
      }
    </style>
  </head>
  <body class="bg-transparent flex items-center justify-center min-h-screen">
    <div
      id="parent-container"
      class="text-center transition-opacity duration-500"
    >
      <div id="line-one" class="eject-line">
        <span class="username" id="username"></span> was timed out
      </div>
      <div id="line-two" class="eject-line">
        By <span class="mod" id="mod"></span> for
        <span class="duration" id="duration"></span>
      </div>
      <div id="line-three" class="eject-line reason"></div>
      <div id="line-four" class="eject-line"></div>
    </div>

    <script>
      // --- Utility Functions ---
      function decodeBase64(str) {
        try {
          return decodeURIComponent(
            atob(str)
              .split("")
              .map((c) => "%" + ("00" + c.charCodeAt(0).toString(16)).slice(-2))
              .join("")
          );
        } catch {
          return str; // fallback if not valid base64
        }
      }

      // --- Get Parameters and Define Content ---
      const params = new URLSearchParams(window.location.search);
      let rawUser = params.get("user") || "A user";
      let username = decodeBase64(rawUser); 

      const mod = decodeURIComponent(params.get("mod") || "a Moderator");
      const duration = decodeURIComponent(params.get("duration") || "300s");
      const reason = decodeURIComponent(
        params.get("reason") || "No reason given."
      );

      // --- Define element references ---
      const elOne = document.getElementById("line-one");
      const elTwo = document.getElementById("line-two");
      const elThree = document.getElementById("line-three");
      const elFour = document.getElementById("line-four");
      const parentContainer = document.getElementById("parent-container");

      // Populate text content for dynamic spans and the reason line
      document.getElementById("username").textContent = username;
      document.getElementById("mod").textContent = mod;
      document.getElementById("duration").textContent = duration;
      elThree.textContent = reason;
      elFour.textContent = ""; 

      // --- Animation Constants ---
      const CHAR_DELAY_S = 0.09;
      const CURSOR_STOP_DELAY_MS = 500;
      const HOLD_TIME_MS = 5000;
      const FADE_TIME_MS = 500;

      // --- Animation Core Logic ---

      // Dynamically create a keyframe rule for the specific width
      function createTypingKeyframes(width) {
        // Use a unique name for each line's animation
        const animationName = `typing-specific-${width.toFixed(2).replace('.', '-')}`;
        const styleSheet = document.styleSheets[0];
        const rule = `
          @keyframes ${animationName} {
            from { width: 0 }
            to { width: ${width}px }
          }
        `;
        // Insert the rule if it doesn't already exist
        if (![...styleSheet.cssRules].some((r) => r.name === animationName)) {
          styleSheet.insertRule(rule, styleSheet.cssRules.length);
        }
        return animationName;
      }
      
      /**
       * Generic function to type out a single line.
       * @param {HTMLElement} el - The line element to type.
       * @param {function} nextFunction - The function to call after this line is typed.
       */
      function typeLine(el, nextFunction) {
        // CRITICAL FIX: Calculate the *final* width of the element.
        // We temporarily allow the content to flow, measure it, then apply the animation CSS.
        el.style.width = 'fit-content';
        el.style.whiteSpace = 'nowrap';
        el.style.overflow = 'hidden';
        
        // Use offsetWidth to get the exact pixel width of the content
        const finalWidth = el.offsetWidth;
        el.style.width = '0'; // Reset width for animation start
        
        // Number of steps for the animation (based on characters)
        const lineText = el.textContent; 
        const numSteps = lineText.length;
        const typingDuration = numSteps * CHAR_DELAY_S;
        
        // Create the animation keyframe rule based on the calculated width
        const typingAnimationName = createTypingKeyframes(finalWidth);

        el.classList.add("cursor");
        el.style.animation =
          `${typingAnimationName} ${typingDuration}s steps(${numSteps}) forwards, ` +
          `blink-caret 0.75s step-end infinite`;

        setTimeout(() => {
          // Stop cursor blink and remove cursor style
          el.classList.remove("cursor");
          el.style.borderRight = "none";
          el.style.animation = "none";
          
          // Ensure the line stays at its final, correct width
          el.style.width = `${finalWidth}px`; 
          
          // Move to the next line after a short delay
          setTimeout(nextFunction, CURSOR_STOP_DELAY_MS);
        }, typingDuration * 1000);
      }

      // Define the sequence of line typing
      function typeLineOne() {
        typeLine(elOne, typeLineTwo);
      }

      function typeLineTwo() {
        typeLine(elTwo, typeLineThree);
      }

      function typeLineThree() {
        typeLine(elThree, typeLineFour);
      }

      function typeLineFour() {
        typeLine(elFour, startCleanup);
      }

      // --- Fade Out ---
      function startCleanup() {
        // Hold the final state for the specified time
        setTimeout(() => {
          parentContainer.style.opacity = "0"; // Trigger fade out

          // After fade out is complete, hide the element completely
          setTimeout(() => {
            parentContainer.style.display = "none";
          }, FADE_TIME_MS);
        }, HOLD_TIME_MS);
      }

      // --- Start Sequence ---
      typeLineOne();
    </script>
  </body>
</html>
